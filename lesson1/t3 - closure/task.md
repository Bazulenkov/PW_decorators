## Замыкания
В программировании:  
**Замыкание** — функция первого класса, в теле которой присутствуют ссылки на 
переменные, объявленные вне тела этой функции в окружающем коде и не являющиеся её параметрами. Говоря другим языком, замыкание — функция, которая ссылается на свободные переменные в своей области видимости. И эти переменные не являются параметрами 
внутренней функции.
Еще их называют фабричными функциями. Фабричные потому, что создают другие функции. Приведем пример:
```python
def maker(n):
    def inner(x):
        return x**n

    return inner


in_power_two = maker(2)  # создаем функцию, которая будет возводить что-то в степень
# двойки
in_power_three = maker(3)  # создаем функцию, которая будет возводить что-то в степень
# тройки

print(type(in_power_two))  # убеждаемся, что это точно функция
print(in_power_two(5))  # возводим 5^2 = 25
print(in_power_three(5))  # возводим 5^3 = 125

# <class 'function'>
# 25
# 125
```

Создаем функцию `maker`, внутри которой объявлена еще одна функция `inner`. `maker` принимает в себя
параметр `n`, `inner` - `x`. `inner` имеет доступ к переменной `n`. В строке
```
in_power_two = maker(2)
```
мы возвращаем функцию `inner(x)` с запомненным параметром `n=2` . Вот это и есть 
основная идея замыкания - сохранять состояния.

Может быть, более наглядным будет реализации этого же замыкания с помощью лямбда-функций:
```python
def maker(n):
    return lambda x: x**n


in_power_two = maker(2)
print(in_power_two)
print(in_power_two(6))
```

Посмотрим, что у нас в замыкании этих функций:
```python
print(in_power_two.__closure__)
address = in_power_three.__closure__
print('address: ', address)
for value in address:
    print('value: ', value.cell_contents)
```
<details><summary>Что погуглить дополнительно?</summary>

lambda-функции. Осторожно! Много, сложно, увлекательно и может увести вообще в неизведанные
миры :)
</details>
