## Декораторы
**Декоратор** - инструмент, позволяющий в достаточно широких пределах расширить 
функциональность
функции без изменения ее исходного кода. И замыкание в python может быть декоратором.
И для применения декоратором даже придумали
специальный синтаксис. Сделаем простейший декоратор, который ничего не делает, но 
перед вызовом
функции будет печатать нам какое-нибудь сообщение.  
[t4-1.py](course://lesson1/t4-decorators/t4-1.py)
```python
def decorator(func):
    def wrapper():
        print("I'm decorator")
        return func()

    return wrapper


@decorator
def my_first_func():
    print("First func")


my_first_func()

# I'm decorator
# First func
```
Сделали функцию `decorator`, которая своим параметром принимает любую функцию. И вложенная в
`decorator` функция будет дополнять поведение функции `func`, печатая перед вызовом декорируемой
функции строку `I'm decorator`.
Далее, перед объявлением декорируемой функции появилось загадочное
```python
@decorator  # декоратор
def my_first_func():  # декорируемая функция
    ...
```
Именно так и применяется декоратор к декорируемой функции. Такой синтаксис является синтаксическим
сахаром вот такой записи (она нам уже знакома):
```python
def my_first_func():
    ...

my_first_func = decorator(my_first_func)
```
Согласитесь, что вариант с `@` гораздо более читаемый и бросающийся в глаза.
Кроме декораторов в виде функций могут быть и декораторы в виде классов. Для этого будет использоваться
магический метод `__call__` у объектов, который позволяет сделать объект вызываемым. Он будет
вызываться каждый раз, когда мы будем вызывать объект, как функцию.
```
obj()
```

Давайте, для примера, напишем класс-декоратор, который подсчитывает вызовы 
декорируемой функции.  
[t4-2.py](course://lesson1/t4-decorators/t4-2.py)
```python
class Tracer:
    def __init__(self, func) -> None:
        self.calls = 0
        self.func = func

    def __call__(self, *args, **kwargs):
        self.calls += 1
        print(f"Calls {self.calls} to {self.func.__name__}")
        return self.func(*args, **kwargs)


@Tracer
def spam(a, b, c):
    return a + b + c


print(spam(1, 2, 3))
print(spam("a", "b", "c"))
print(spam)

# Calls 1 to spam
# 6
# Calls 2 to spam
# abc
# <class '__main__.Tracer'>
```

Фактически, мы с вами в этом примере подменяем объект функции `spam` (вы помните, что 
в python всё
объекты?) на объект класса `Tracer`. Что же происходит в этом примере? Давайте заменим конструкцию с
`@` на ее обычный эквивалент через присваивание:
```python
def spam(a, b, c):
    ...

spam = Tracer(spam)
```

В `spam` мы просто положили объект, в котором храним ссылку на функцию `spam` и количество вызовов,
равное нулю.  

Далее, когда мы делаем `print(spam(1,2,3))`, у объекта Tracer вызывается метод `__call__`, в котором
происходит инкрементирование счетчика вызовов, вывод сообщения и возврат результата декориремой
функции с теми параметрами, которые ей были переданы. Они спрятаны в волшебных 
параметрах `*args` и `**kwargs`. Но про такие штуки распаковки списков и словарей вы 
уже должны знать ;) При этом, нам абсолютно все равно, какие параметры у функции `spam`.

На мой взгляд, такой способ реализации декораторов через классы более интуитивен. В результате
получается вызываемый объект, способный хранить и изменять свое состояние. Но у него есть свои
недостатки. Но для начала я просто скажу, что можно декорировать классы и их методы 
:) 

А теперь, о недостатках:  
Декоратор через `__call__` не может перехватить вызов метода класса, к которому он применен. Это
накладывает ограничения на использование декораторов в виде объекта.
```python
class Decorator:
    def __init__(self, func) -> None:
        self.func = func

    def __call__(self, *args):
        self.func(*args)
        print("Decorated")


class C:
    @Decorator
    def method(self, x, y):
        print(x + y)


c = C()
c.method(1, 2)  # нам нужен в явном виде self, а его нет и случается ошибка
```
Возможно делать и декораторы классов, но это тема отдельного разговора. И прежде чем его начать, было бы
неплохо, чтобы вы прочитали что-то про атрибуты классов и функций в python, и про методы объектов,
связанные со взаимодействиями с их аргументами, аля `__getattribute__` , `__getattr__` и т.п.

Что погуглить дополнительно?:
* args и kwargs в Python
* атрибуты функций и атрибуты классов
* PEP 232
* декораторы для классов

Как же нам применить декоратор к методу класса? Все просто, нужно написать декоратор в виде функции.
Делаем финт ушами с `*args` и получаем рабочее решение:  
[t4-5.py](course://lesson1/t4-decorators/t4-5.py)
```python
def decorator(func):
    def wrapper(*args):
        print("Decorated")
        return func(*args)

    return wrapper


class C:
    @decorator
    def method(self, x, y):
        print(x + y)


c = C()
c.method(6, 7)  # а тут все работает как надо
```


